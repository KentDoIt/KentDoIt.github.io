---
title: JS == vs ===
categories: JavaScript
tags:
  - 運算子
  - JS 釘孤枝
  - JavaScript
description: 此篇主要探討兩種比較運算子 ==、=== 的差異。
abbrlink: 3699626031
date: 2022-05-10 11:07:50
---

![綜合比較表 src：https://github.com/dorey/JavaScript-Equality-Table](https://imgur.com/7TLQ2Yr.jpg)

比較運算子注意事項

{% note default %}
在 JavaScript 中除了基礎型別（Primitive Type）以外的型別（ex: 陣列、物件）在做比較時，判斷的是兩者是否指向同一個 `reference`，而非判斷兩者的值是否相同。
{% endnote %}

e.g. 陣列判斷

```js
let a = [1 , 2];
let b = [1 , 2];
console.log(a == b); // false

let c = b;
console.log(c == b); // true
```

{% note default %}
下方會範例會使用基礎型別（Primitive Type）來演示。
{% endnote %}

## =

> [Assignment 賦值運算子](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment)

{% note primary %}
assignment：將等號右邊值賦予到左邊的變數。
{% endnote %}

```js e.g. 賦予值
let num = 10;
```

## ==

> [Equality 相等比較](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality)，

{% note primary %}
equality：比較等號兩邊值是否相同，當等號兩邊型別不同時，會先依照規則轉型再進行比對。（除了物件外，幾乎會轉型為 number 後在做比較）
{% endnote %}

{% note default %}
紀錄一下看到的其它名稱：
Double equals operator （寬鬆相等）
equality comparison operator（相等比較運算子）
abstract comparison operator（抽象比較運算子）
{% endnote %}

```js e.g. ==比較運算
console.log('1' == 1); // true，1 == 1
```

![== 比較表](https://imgur.com/9I2G4tQ.jpg)

## ===

> [Strict equality 嚴格相等比較](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_equality)

{% note primary %}
strict equality：比較等號兩邊 `型別` 以及 `數值` 是否 `都相同`。
{% endnote %}

{% note default %}
紀錄一下看到的其它名稱：
identity comparison operator（身份比較運算子）
strict comparison operator（嚴格比較運算子）
{% endnote %}

```js e.g. ==比較運算
console.log('1' === 1); // false
```

![=== 比較表](https://imgur.com/I3piMnw.jpg)

## 自動轉型差異

==：會依照規則轉型後再比較。
===：不會轉型直接比較。

## 例外

> == 寬鬆比對下等號兩邊為 undefined 和 null 則回傳 true。

```js
console.log(undefined == null); // true
```

> == 寬鬆比對下空字串（字串為空或是僅有空白）則代表 false。

```js
console.log('' == false);    // true，0 == 0
console.log('  ' == false);  // true，0 == 0
```

> == 寬鬆比對下等號兩邊型別不同時，除了 object 外幾乎是轉型成 number 在做比對，

```js
console.log(true == 1);      // true，1
console.log(true == '1');    // true，1 == 1
console.log(true == 'true'); // false，1 == NaN
```

> 非基礎型別、symbols 還需要比較 reference，相同才會回傳 true。

```js
console.log(true === true);           // true
console.log(Symbol(1) === Symbol(1)); // false
console.log({} === {});               // false

const obj = {};
const sym = Symbol();
console.log([obj].includes(obj));     // true
console.log([sym].includes(sym));     // true
```

> NaN

- 等號其中一邊只要有 NaN 則回傳 false 。（一般會使用 isNan 去判斷 NaN）

```js
console.log(NaN == NaN);  // false
console.log(NaN === NaN); // false
```

> 兩者皆為 0 則回傳 true。（不管正負）

```js
console.log(0 === -0);    // true
console.log(1 === -1);    // false
```

## conclusion

> == 特殊使用情境

```js 判斷是否為 null、undefined
if (x === null || x === undefined) {
  // ...
}

// == 特性等號左右兩邊為 null、undefined 會回傳 true
if (x == null) {
  // ...
}
```

```js 判斷 typeof 值
// 因為 typeof 出來的值會是固定的 javascript 型別，只是可能隨著時間流逝版本會有差異（ex: bigint）
if( typeof(x) == 'string') {
   ...
}
```

{% note default %}
建議還是使用 === 嚴格比對。（除非非常暸解，且熟悉特殊情境時使用 ex：判斷是否為 null、undefined）
{% endnote %}

## references

[為了轉生而點技能-JavaScript，難題紀錄(二)隱式轉換規則及===、==](https://ithelp.ithome.com.tw/articles/10282758)
[JS中的 {} + {} 與 {} + [] 的結果是什麼？](https://eddychang.me/js-object-plus-object)